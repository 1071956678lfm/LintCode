## **173. Binary Search Tree Iterator**

- Target

```
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.
```

![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

- 分析：

典型的前序遍历，通过查询遍历序列中的位置即可进行 `next()` 和 `hasNext()` 的判定

- 题解方案

1. 递归方式：

```
do(root.left)
...
do(root)
...
do(root.right)
```

根据如上典型的遍历方式，可以很快地得出如下代码

```java
class BSTIterator {
    private static List<Integer> list = new LinkedList<>();
    private static int index = 0;

    public BSTIterator(TreeNode root) {
        init(root);
    }

    private static void init(TreeNode root) {
        if (null == root) {
            return;
        }
        if (root.left != null) {
            init(root.left);
        }
        list.add(root.val);
        if (root.right != null) {
            init(root.right);
        }
    }

    /**
     * @return the next smallest number
     */
    public int next() {
        return list.get(index++);
    }

    /**
     * @return whether we have a next smallest number
     */
    public boolean hasNext() {
        return index < list.size();
    }

}

```

不难看出，就是在初始化的过程中直接在内部组合一个 `List` ，作为前序遍历列表的内容；同时维护一个指针 `index` 来指示遍历的节点内容。

这个方案可以 AC ，但是时间和空间利用效率均不高。

现考虑其他的实现方式

2. 递归 -> 迭代

递归进行先序遍历，完全可以利用迭代来进行；借助 `Stack` 来进行实现

思路（伪代码）：

若某个非空节点含有一个左子树，则迭代继续寻找其左子树节点 $v$ ，并且将节点 $v$  `push` 进入栈中，直到节点 $v$ 不再存在左子树。

出了上述的循环迭代之后，先把

```
if root is null:
	return
else 
	while ndoe.leftChild is not null:
			stack.push(node)
			node.leftChild - > node
```

